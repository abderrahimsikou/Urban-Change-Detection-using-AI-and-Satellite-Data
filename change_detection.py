# -*- coding: utf-8 -*-
"""change_detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lYKt3HXYsAnIxiHtIzbmpL04EjETQfXX
"""

import rasterio
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.models import load_model

from google.colab import drive
drive.mount('/content/drive')

model = load_model('/content/model.h5')

"""Load Sentinel-2 Bands"""

# Calculate NDVI
def calculate_ndvi(b08_path, b04_path):
    # Read Satellite Image
    with rasterio.open(b08_path) as nir_src:
        nir = nir_src.read(1).astype('float32')
    with rasterio.open(b04_path) as red_src:
        red = red_src.read(1).astype('float32')
    # Calculating NDVI
    ndvi =  (nir - red) / (nir + red + 1e-6)
    return ndvi

"""Satellite Image 2017"""

# Satellite Image Path 2017
band04_2017 = '/content/drive/MyDrive/T40RCN_20170613T064621_B04_10m.jp2'
band08_2017 = '/content/drive/MyDrive/T40RCN_20170613T064621_B08_10m.jp2'

ndvi_2017 = calculate_ndvi(band08_2017, band04_2017)

# Draw Results Of 2017
plt.figure(figsize=(8, 5))
plt.title('NDVI - Urban Detection 2017')
plt.imshow(ndvi_2017, cmap='RdYlGn_r')
plt.colorbar(label='NDVI (Positive = Urban')
plt.show()

"""Satellite Image 2025"""

# Satellite Image Path 2025
band04_2025 = '/content/drive/MyDrive/T40RCN_20250611T064641_B04_10m.jp2'
band08_2025 = '/content/drive/MyDrive/T40RCN_20250611T064641_B08_10m.jp2'

ndvi_2025 = calculate_ndvi(band08_2025, band04_2025)

# Draw Results Of 2017
plt.figure(figsize=(8, 5))
plt.title('NDVI - Urban 2025')
plt.imshow(ndvi_2025, cmap='RdYlGn_r')
plt.colorbar(label='NDVI (Positive = Urban')
plt.show()

def predict_full_image(model, ndvi_2017, ndvi_2025, patch_size=256):
    h, w = ndvi_2017.shape
    padded_h = (h // patch_size + 1) * patch_size
    padded_w = (w // patch_size + 1) * patch_size

    prediction = np.zeros((padded_h, padded_w), dtype='uint8')

    padded_old = np.zeros((padded_h, padded_w), dtype='float32')
    padded_new = np.zeros((padded_h, padded_w), dtype='float32')
    padded_old[:h, :w] = ndvi_2017
    padded_new[:h, :w] = ndvi_2025

    for i in range(0, padded_h, patch_size):
        for j in range(0, padded_w, patch_size):
            patch_old = padded_old[i:i+patch_size, j:j+patch_size]
            patch_new = padded_new[i:i+patch_size, j:j+patch_size]

            patch = np.stack([patch_old, patch_new], axis=-1) # shape: (256, 256, 2)
            patch_input = patch[np.newaxis, ...] # shape: (1, 256, 256, 2)

            # Prediction
            pred = model.predict(patch_input)
            pred_mask = (pred[0, ..., 0] > 0.5).astype('uint8')

            prediction[i:i+patch_size, j:j+patch_size] = pred_mask

    return prediction[:h, :w]

def overlay_on_ndvi(ndvi_base, change_mask, alpha=0.5):
    ndvi_norm = (ndvi_base - ndvi_base.min()) / (ndvi_base.max() - ndvi_base.min())
    gray_rgb = np.stack([ndvi_norm]*3, axis=-1)

    red_overlay = np.zeros_like(gray_rgb)
    red_overlay[..., 0] = change_mask

    result = (1 - alpha) * gray_rgb + alpha * red_overlay
    return result

# Aplly Prediction
change_map = predict_full_image(model, ndvi_2017, ndvi_2025)

"""Urban Change (result)"""

enhanced = overlay_on_ndvi(ndvi_2017,change_map, alpha=0.5)
plt.figure(figsize=(12,6))
plt.title('Urban Change Mask')
plt.imshow(enhanced)
plt.axis('off')
plt.show()